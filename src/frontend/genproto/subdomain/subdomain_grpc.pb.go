// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: subdomain.proto

package subdomain

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ApiQueryServiceClient is the client API for ApiQueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiQueryServiceClient interface {
	GetSubdomainsByApiQuery(ctx context.Context, in *ApiQueryRequest, opts ...grpc.CallOption) (*ApiQueryResponse, error)
}

type apiQueryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewApiQueryServiceClient(cc grpc.ClientConnInterface) ApiQueryServiceClient {
	return &apiQueryServiceClient{cc}
}

func (c *apiQueryServiceClient) GetSubdomainsByApiQuery(ctx context.Context, in *ApiQueryRequest, opts ...grpc.CallOption) (*ApiQueryResponse, error) {
	out := new(ApiQueryResponse)
	err := c.cc.Invoke(ctx, "/subdomain.ApiQueryService/GetSubdomainsByApiQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiQueryServiceServer is the server API for ApiQueryService service.
// All implementations must embed UnimplementedApiQueryServiceServer
// for forward compatibility
type ApiQueryServiceServer interface {
	GetSubdomainsByApiQuery(context.Context, *ApiQueryRequest) (*ApiQueryResponse, error)
	mustEmbedUnimplementedApiQueryServiceServer()
}

// UnimplementedApiQueryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedApiQueryServiceServer struct {
}

func (UnimplementedApiQueryServiceServer) GetSubdomainsByApiQuery(context.Context, *ApiQueryRequest) (*ApiQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubdomainsByApiQuery not implemented")
}
func (UnimplementedApiQueryServiceServer) mustEmbedUnimplementedApiQueryServiceServer() {}

// UnsafeApiQueryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiQueryServiceServer will
// result in compilation errors.
type UnsafeApiQueryServiceServer interface {
	mustEmbedUnimplementedApiQueryServiceServer()
}

func RegisterApiQueryServiceServer(s grpc.ServiceRegistrar, srv ApiQueryServiceServer) {
	s.RegisterService(&ApiQueryService_ServiceDesc, srv)
}

func _ApiQueryService_GetSubdomainsByApiQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiQueryServiceServer).GetSubdomainsByApiQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/subdomain.ApiQueryService/GetSubdomainsByApiQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiQueryServiceServer).GetSubdomainsByApiQuery(ctx, req.(*ApiQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiQueryService_ServiceDesc is the grpc.ServiceDesc for ApiQueryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiQueryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subdomain.ApiQueryService",
	HandlerType: (*ApiQueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSubdomainsByApiQuery",
			Handler:    _ApiQueryService_GetSubdomainsByApiQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "subdomain.proto",
}

// BruteServiceClient is the client API for BruteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BruteServiceClient interface {
	GetSubdomainsByBruteForce(ctx context.Context, in *BruteForceRequest, opts ...grpc.CallOption) (*BruteForceResponse, error)
}

type bruteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBruteServiceClient(cc grpc.ClientConnInterface) BruteServiceClient {
	return &bruteServiceClient{cc}
}

func (c *bruteServiceClient) GetSubdomainsByBruteForce(ctx context.Context, in *BruteForceRequest, opts ...grpc.CallOption) (*BruteForceResponse, error) {
	out := new(BruteForceResponse)
	err := c.cc.Invoke(ctx, "/subdomain.BruteService/GetSubdomainsByBruteForce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BruteServiceServer is the server API for BruteService service.
// All implementations must embed UnimplementedBruteServiceServer
// for forward compatibility
type BruteServiceServer interface {
	GetSubdomainsByBruteForce(context.Context, *BruteForceRequest) (*BruteForceResponse, error)
	mustEmbedUnimplementedBruteServiceServer()
}

// UnimplementedBruteServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBruteServiceServer struct {
}

func (UnimplementedBruteServiceServer) GetSubdomainsByBruteForce(context.Context, *BruteForceRequest) (*BruteForceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubdomainsByBruteForce not implemented")
}
func (UnimplementedBruteServiceServer) mustEmbedUnimplementedBruteServiceServer() {}

// UnsafeBruteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BruteServiceServer will
// result in compilation errors.
type UnsafeBruteServiceServer interface {
	mustEmbedUnimplementedBruteServiceServer()
}

func RegisterBruteServiceServer(s grpc.ServiceRegistrar, srv BruteServiceServer) {
	s.RegisterService(&BruteService_ServiceDesc, srv)
}

func _BruteService_GetSubdomainsByBruteForce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BruteForceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BruteServiceServer).GetSubdomainsByBruteForce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/subdomain.BruteService/GetSubdomainsByBruteForce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BruteServiceServer).GetSubdomainsByBruteForce(ctx, req.(*BruteForceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BruteService_ServiceDesc is the grpc.ServiceDesc for BruteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BruteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subdomain.BruteService",
	HandlerType: (*BruteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSubdomainsByBruteForce",
			Handler:    _BruteService_GetSubdomainsByBruteForce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "subdomain.proto",
}

// ResolveDnsServiceClient is the client API for ResolveDnsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResolveDnsServiceClient interface {
	ResolveDns(ctx context.Context, in *ResolveDnsRequest, opts ...grpc.CallOption) (*ResolveDnsResponse, error)
}

type resolveDnsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResolveDnsServiceClient(cc grpc.ClientConnInterface) ResolveDnsServiceClient {
	return &resolveDnsServiceClient{cc}
}

func (c *resolveDnsServiceClient) ResolveDns(ctx context.Context, in *ResolveDnsRequest, opts ...grpc.CallOption) (*ResolveDnsResponse, error) {
	out := new(ResolveDnsResponse)
	err := c.cc.Invoke(ctx, "/subdomain.ResolveDnsService/ResolveDns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResolveDnsServiceServer is the server API for ResolveDnsService service.
// All implementations must embed UnimplementedResolveDnsServiceServer
// for forward compatibility
type ResolveDnsServiceServer interface {
	ResolveDns(context.Context, *ResolveDnsRequest) (*ResolveDnsResponse, error)
	mustEmbedUnimplementedResolveDnsServiceServer()
}

// UnimplementedResolveDnsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedResolveDnsServiceServer struct {
}

func (UnimplementedResolveDnsServiceServer) ResolveDns(context.Context, *ResolveDnsRequest) (*ResolveDnsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveDns not implemented")
}
func (UnimplementedResolveDnsServiceServer) mustEmbedUnimplementedResolveDnsServiceServer() {}

// UnsafeResolveDnsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResolveDnsServiceServer will
// result in compilation errors.
type UnsafeResolveDnsServiceServer interface {
	mustEmbedUnimplementedResolveDnsServiceServer()
}

func RegisterResolveDnsServiceServer(s grpc.ServiceRegistrar, srv ResolveDnsServiceServer) {
	s.RegisterService(&ResolveDnsService_ServiceDesc, srv)
}

func _ResolveDnsService_ResolveDns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveDnsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResolveDnsServiceServer).ResolveDns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/subdomain.ResolveDnsService/ResolveDns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResolveDnsServiceServer).ResolveDns(ctx, req.(*ResolveDnsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ResolveDnsService_ServiceDesc is the grpc.ServiceDesc for ResolveDnsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResolveDnsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subdomain.ResolveDnsService",
	HandlerType: (*ResolveDnsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveDns",
			Handler:    _ResolveDnsService_ResolveDns_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "subdomain.proto",
}

// PortScanServiceClient is the client API for PortScanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PortScanServiceClient interface {
	ScanForOpenPorts(ctx context.Context, opts ...grpc.CallOption) (PortScanService_ScanForOpenPortsClient, error)
}

type portScanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPortScanServiceClient(cc grpc.ClientConnInterface) PortScanServiceClient {
	return &portScanServiceClient{cc}
}

func (c *portScanServiceClient) ScanForOpenPorts(ctx context.Context, opts ...grpc.CallOption) (PortScanService_ScanForOpenPortsClient, error) {
	stream, err := c.cc.NewStream(ctx, &PortScanService_ServiceDesc.Streams[0], "/subdomain.PortScanService/ScanForOpenPorts", opts...)
	if err != nil {
		return nil, err
	}
	x := &portScanServiceScanForOpenPortsClient{stream}
	return x, nil
}

type PortScanService_ScanForOpenPortsClient interface {
	Send(*PortScanRequest) error
	Recv() (*Subdomain, error)
	grpc.ClientStream
}

type portScanServiceScanForOpenPortsClient struct {
	grpc.ClientStream
}

func (x *portScanServiceScanForOpenPortsClient) Send(m *PortScanRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *portScanServiceScanForOpenPortsClient) Recv() (*Subdomain, error) {
	m := new(Subdomain)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PortScanServiceServer is the server API for PortScanService service.
// All implementations must embed UnimplementedPortScanServiceServer
// for forward compatibility
type PortScanServiceServer interface {
	ScanForOpenPorts(PortScanService_ScanForOpenPortsServer) error
	mustEmbedUnimplementedPortScanServiceServer()
}

// UnimplementedPortScanServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPortScanServiceServer struct {
}

func (UnimplementedPortScanServiceServer) ScanForOpenPorts(PortScanService_ScanForOpenPortsServer) error {
	return status.Errorf(codes.Unimplemented, "method ScanForOpenPorts not implemented")
}
func (UnimplementedPortScanServiceServer) mustEmbedUnimplementedPortScanServiceServer() {}

// UnsafePortScanServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PortScanServiceServer will
// result in compilation errors.
type UnsafePortScanServiceServer interface {
	mustEmbedUnimplementedPortScanServiceServer()
}

func RegisterPortScanServiceServer(s grpc.ServiceRegistrar, srv PortScanServiceServer) {
	s.RegisterService(&PortScanService_ServiceDesc, srv)
}

func _PortScanService_ScanForOpenPorts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PortScanServiceServer).ScanForOpenPorts(&portScanServiceScanForOpenPortsServer{stream})
}

type PortScanService_ScanForOpenPortsServer interface {
	Send(*Subdomain) error
	Recv() (*PortScanRequest, error)
	grpc.ServerStream
}

type portScanServiceScanForOpenPortsServer struct {
	grpc.ServerStream
}

func (x *portScanServiceScanForOpenPortsServer) Send(m *Subdomain) error {
	return x.ServerStream.SendMsg(m)
}

func (x *portScanServiceScanForOpenPortsServer) Recv() (*PortScanRequest, error) {
	m := new(PortScanRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PortScanService_ServiceDesc is the grpc.ServiceDesc for PortScanService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PortScanService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subdomain.PortScanService",
	HandlerType: (*PortScanServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ScanForOpenPorts",
			Handler:       _PortScanService_ScanForOpenPorts_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "subdomain.proto",
}
